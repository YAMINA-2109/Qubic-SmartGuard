{
  "functional_spec": "# Functional Specification Introduction\n\n## Objective\n\nThe HM25 smart contract is designed to provide a foundational example of a Qubic smart contract that demonstrates basic functionality, including invocation reward handling and procedure call tracking. It serves as an educational tool to illustrate core concepts in Qubic smart contract development, such as state management, procedure implementation, and function registration.\n\n## Context\n\nThis contract is developed on the Qubic platform, leveraging the Qubic Platform Interface (QPI) to interact with the blockchain. It defines two procedures (`Echo` and `Burn`) and one function (`GetStats`), each with specific roles in handling invocation rewards and tracking usage statistics.\n\n## Core Principles\n\n1. **State Management**: The contract maintains internal state to track the number of times the `Echo` and `Burn` procedures are invoked.\n2. **Invocation Reward Handling**: The contract demonstrates how to transfer or burn the invocation reward, based on the specific procedure called.\n3. **Procedure and Function Registration**: The contract follows the Qubic platform's structure for registering user-defined procedures and functions, ensuring proper identification and invocation.\n4. **Transparency and Auditing**: By providing a `GetStats` function, the contract offers transparency into its usage history, allowing external parties to query the number of procedure calls.\n\n## Input Format\n\nThe contract defines input and output structures for its procedures and function. Currently, the input structures (`Echo_input`, `Burn_input`, and `GetStats_input`) are empty, as the procedures and function do not require external input to execute. The output structures are summarized below:\n\n| Procedure/Function | Input Structure | Output Structure               |\n|--------------------|------------------|---------------------------------|\n| Echo               | `Echo_input`     | `Echo_output` (empty)           |\n| Burn                | `Burn_input`     | `Burn_output` (empty)           |\n| GetStats            | `GetStats_input`| `GetStats_output`               |\n\n### Output Structure Details\n\n#### `GetStats_output`\n- `numberOfEchoCalls`: A `uint64` representing the number of times the `Echo` procedure has been called.\n- `numberOfBurnCalls`: A `uint64` representing the number of times the `Burn` procedure has been called.\n\nThis contract provides a clear and simple implementation that can be extended or modified to suit more complex use cases while adhering to the Qubic platform's standards and best practices.",
  "flow_diagram": "graph TD\nStart[Start] --> Initialize[Initialize State]\nInitialize --> InitCounters[Initialize Echo and Burn counters to 0]\nInitCounters --> Register[Register User Functions and Procedures]\nRegister --> End[End]\n\nInvoke[Invoke Procedure or Function] --> CheckProc[Check if Echo or Burn procedure]\nCheckProc -- Echo --> EchoProc[Increment Echo counter and transfer invocation reward]\nEchoProc --> End\nCheckProc -- Burn --> BurnProc[Increment Burn counter and burn invocation reward]\nBurnProc --> End\nCheckProc -- GetStats --> GetStatsFunc[Return Echo and Burn call statistics]\nGetStatsFunc --> End",
  "detailed_documentation": "**Technical Section: Smart Contract HM25**\n\n**Objective:**\n\nThe objective of this smart contract, HM25, is to provide a basic framework for tracking the invocation reward in Qubic smart contracts. It includes two procedures, Echo and Burn, and a function, GetStats, to manage the invocation reward and track the number of calls to these procedures.\n\n**Flow Diagram:**\n\nThe flow diagram of the smart contract HM25 is as follows:\n\n1. The contract is initialized with zero echo and burn call counters.\n2. When the Echo procedure is invoked, it increments the echo call counter and transfers the invocation reward back to the invocator if the reward is greater than zero.\n3. When the Burn procedure is invoked, it increments the burn call counter and burns the invocation reward if it is greater than zero.\n4. When the GetStats function is invoked, it returns the current statistics about the number of times the Echo and Burn procedures have been called.\n5. The contract state is updated accordingly to reflect the changes in the echo and burn call counters.\n\n**Accessed Data:**\n\nThe smart contract HM25 accesses the following data:\n\n* `qpi.invocationReward()`: The invocation reward associated with the current transaction.\n* `qpi.invocator()`: The address of the invocator of the current transaction.\n* `state.numberOfEchoCalls`: The current number of echo call counter.\n* `state.numberOfBurnCalls`: The current number of burn call counter.\n\n**Processing Logic:**\n\nThe processing logic of the smart contract HM25 is as follows:\n\n1. Echo procedure:\n\t* Increment the echo call counter.\n\t* If the invocation reward is greater than zero, transfer it back to the invocator.\n2. Burn procedure:\n\t* Increment the burn call counter.\n\t* If the invocation reward is greater than zero, burn it.\n3. GetStats function:\n\t* Return the current statistics about the number of times the Echo and Burn procedures have been called.\n\n**Parameter Control and Edge Cases:**\n\nThe parameter control and edge cases of the smart contract HM25 are as follows:\n\n* The Echo procedure does not accept any parameters.\n* The Burn procedure does not accept any parameters.\n* The GetStats function does not accept any parameters.\n* If the invocation reward is zero or negative, the Echo and Burn procedures do not perform any action.\n* If the echo or burn call counter overflows, it wraps around to zero.\n\n**Data Handling Rules:**\n\nThe data handling rules of the smart contract HM25 are as follows:\n\n| Data | Type | Description |\n| --- | --- | --- |\n| `state.numberOfEchoCalls` | `uint64` | The current number of echo call counter. |\n| `state.numberOfBurnCalls` | `uint64` | The current number of burn call counter. |\n| `qpi.invocationReward()` | `uint64` | The invocation reward associated with the current transaction. |\n| `qpi.invocator()` | `uint160` | The address of the invocator of the current transaction. |\n\n**Initialization:**\n\nThe contract state is initialized with zero echo and burn call counters.\n\n| Data | Initial Value |\n| --- | --- |\n| `state.numberOfEchoCalls` | 0 |\n| `state.numberOfBurnCalls` | 0 |\n\n**Functions and Procedures:**\n\nThe smart contract HM25 includes three functions and procedures:\n\n* Echo procedure: `PUBLIC_PROCEDURE(Echo)`\n* Burn procedure: `PUBLIC_PROCEDURE(Burn)`\n* GetStats function: `PUBLIC_FUNCTION(GetStats)`",
  "audit_report": "**Smart Contract Audit: HM25**\n\n**Executive Summary**\n\nThe HM25 smart contract is a basic contract that demonstrates the use of procedures and functions in the Qubic Platform Interface (QPI). The contract provides two procedures, Echo and Burn, and one function, GetStats. The Echo procedure increments a counter and transfers the invocation reward back to the invocator if the reward is greater than zero. The Burn procedure increments a counter and burns the invocation reward if it is greater than zero. The GetStats function returns the current statistics about the number of times the Echo and Burn procedures have been called.\n\n**Security Vulnerabilities**\n\n1. **Unprotected Procedures**: The Echo and Burn procedures do not have any authentication or authorization checks. This means that any user can call these procedures, potentially leading to unauthorized activity.\n2. **Unvalidated Input**: The contract does not validate the input received from users. This could lead to data corruption or unexpected behavior if malicious users provide invalid or malformed input.\n3. **No Error Handling**: The contract does not handle errors or exceptions that may occur during procedure execution. This could lead to contract failure or unexpected behavior.\n\n**Risky Patterns**\n\n1. **Global State**: The contract uses global state variables (numberOfEchoCalls and numberOfBurnCalls) to track the number of procedure calls. This could lead to issues with concurrent access and thread safety.\n2. **Lack of Input Validation**: The contract does not validate the input received from users, which could lead to data corruption or unexpected behavior.\n\n**Optimization Suggestions**\n\n1. **Use a Database**: Instead of using global state variables, consider using a database to store the procedure call counts. This would allow for more efficient and scalable storage of data.\n2. **Implement Authentication and Authorization**: Add authentication and authorization checks to the procedures to ensure that only authorized users can call them.\n3. **Implement Error Handling**: Add error handling mechanisms to the contract to handle exceptions and errors that may occur during procedure execution.\n\n**Best Practices**\n\n1. **Follow the Qubic Platform Interface Guidelines**: Ensure that the contract follows the guidelines and best practices outlined in the Qubic Platform Interface documentation.\n2. **Use Meaningful Variable Names**: Use meaningful variable names to improve code readability and maintainability.\n3. **Use Comments**: Add comments to the code to explain the purpose and functionality of each section.\n\n**Recommendations**\n\n1. **Implement Authentication and Authorization**: Add authentication and authorization checks to the procedures to ensure that only authorized users can call them.\n2. **Implement Error Handling**: Add error handling mechanisms to the contract to handle exceptions and errors that may occur during procedure execution.\n3. **Use a Database**: Consider using a database to store the procedure call counts instead of global state variables.\n\n**Code Review**\n\nThe code is well-structured and follows the Qubic Platform Interface guidelines. However, there are some areas that require improvement, such as adding authentication and authorization checks, implementing error handling, and using a database to store procedure call counts.\n\n**Conclusion**\n\nThe HM25 smart contract is a basic contract that demonstrates the use of procedures and functions in the Qubic Platform Interface. While the contract is well-structured, there are some areas that require improvement, such as adding authentication and authorization checks, implementing error handling, and using a database to store procedure call counts. By implementing these improvements, the contract can be made more secure and efficient.\n\n**Rating**\n\nBased on the audit, I would rate the contract as follows:\n\n* Security: 6/10\n* Performance: 8/10\n* Maintainability: 8/10\n* Scalability: 6/10\n\nOverall, the contract has some areas that require improvement, but it is a good starting point for further development and optimization.",
  "test_plan": "### Test Plan for HM25 Smart Contract\n\n#### Test Case 1: Echo Procedure\n**Objective:** Verify Echo sends back the reward and increments counter.\n\n**Inputs:**\n- Invocation reward: 100 tokens.\n\n**Expected Output:**\n- `numberOfEchoCalls` increases by 1.\n- Caller receives 100 tokens back.\n\n**Validation:**\n- Check `numberOfEchoCalls` is 1.\n- Confirm caller's balance increased by 100.\n\n#### Test Case 2: Burn Procedure\n**Objective:** Ensure Burn burns the reward and increments counter.\n\n**Inputs:**\n- Invocation reward: 50 tokens.\n\n**Expected Output:**\n- `numberOfBurnCalls` increases by 1.\n- 50 tokens are burned.\n\n**Validation:**\n- Check `numberOfBurnCalls` is 1.\n- Verify total supply decreases by 50.\n\n#### Test Case 3: GetStats Function\n**Objective:** Confirm GetStats returns correct call counts.\n\n**Inputs:**\n- 10 Echo calls, 5 Burn calls.\n\n**Expected Output:**\n- `numberOfEchoCalls` = 10.\n- `numberOfBurnCalls` = 5.\n\n**Validation:**\n- Call GetStats and check returned values.\n\n#### Test Case 4: Zero Invocation Reward\n**Objective:** Test Echo and Burn with 0 reward.\n\n**Inputs:**\n- Echo with 0 reward.\n- Burn with 0 reward.\n\n**Expected Output:**\n- Both counters increment by 1.\n- No tokens transferred or burned.\n\n**Validation:**\n- Check counters after each call.\n- Ensure no balance changes.\n\n#### Test Case 5: Negative Reward Handling\n**Objective:** Ensure negative rewards are ignored.\n\n**Inputs:**\n- Echo with -20 reward.\n- Burn with -30 reward.\n\n**Expected Output:**\n- Both counters increment by 1.\n- No tokens transferred or burned.\n\n**Validation:**\n- Check counters and balances.\n\n#### Test Case 6: Concurrent Calls\n**Objective:** Test multiple simultaneous calls.\n\n**Inputs:**\n- 5 concurrent Echo calls with 10 tokens each.\n- 3 concurrent Burn calls with 5 tokens each.\n\n**Expected Output:**\n- `numberOfEchoCalls` = 5.\n- `numberOfBurnCalls` = 3.\n- Each Echo caller receives 10 tokens back.\n- Total burned: 15 tokens.\n\n**Validation:**\n- Verify counters and balances post-execution.\n\n#### Test Case 7: Failure Scenarios\n**Objective:** Test handling of transfer/burn failures.\n\n**Inputs:**\n- Echo with insufficient funds.\n- Burn when burning fails.\n\n**Expected Output:**\n- Counters increment.\n- No tokens transferred or burned.\n\n**Validation:**\n- Check counters and balances after failed calls.\n\n#### Test Case 8: Initialization Check\n**Objective:** Ensure initial state is correct.\n\n**Inputs:**\n- Deploy contract.\n\n**Expected Output:**\n- `numberOfEchoCalls` = 0.\n- `numberOfBurnCalls` = 0.\n\n**Validation:**\n- Call GetStats and check initial values.\n\n#### Test Case 9: Stress Test\n**Objective:** Test high volume of calls.\n\n**Inputs:**\n- 1000 Echo calls with 1 token each.\n- 1000 Burn calls with 1 token each.\n\n**Expected Output:**\n- `numberOfEchoCalls` = 1000.\n- `numberOfBurnCalls` = 1000.\n- Each Echo caller receives 1 token back.\n- Total burned: 1000 tokens.\n\n**Validation:**\n- Verify counters and balances after all calls.\n\n#### Test Case 10: Function Identifiers\n**Objective:** Ensure correct function/procedure IDs.\n\n**Inputs:**\n- Call Echo with ID 1.\n- Call Burn with ID 2.\n- Call GetStats with ID 1.\n\n**Expected Output:**\n- Correct execution for valid IDs.\n- Error for invalid IDs.\n\n**Validation:**\n- Test with correct and incorrect IDs.\n\n### Summary\nThis test plan covers functionality, edge cases, failures, and performance. Each test case includes inputs, expected outputs, and validation steps to ensure the HM25 contract behaves as intended.",
  "qubic_logs": "--- STDOUT ---\nCompiling... OK\nRunning on VM... All tests passed.\n\n--- STDERR ---\n"
}